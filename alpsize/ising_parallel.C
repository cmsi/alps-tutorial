/*****************************************************************************
*
* Tutorial: How to ALPSize your applications
*
* Copyright (C) 2005-2013 by Synge Todo <wistaria@comp-phys.org>
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************/

#include <cmath>
#include <iostream>
#include <vector>
#include <boost/random.hpp>
#include <boost/timer.hpp>
#include <mpi.h>

#define L 128
#define T 1.0
#define MCSTEP (1 << 15)
#define MCTHRM (MCSTEP >> 3)
#define SEED 93812

// a vector with 'tabs' on both sides: elements at i = -1 as well as
// i = size() are also accessible
template<typename U>
class tabbed_vector {
public:
  typedef U value_type;
  typedef typename std::vector<value_type>::size_type size_type;
  explicit tabbed_vector(size_type n = 0) : vector_(n + 2) {}
  explicit tabbed_vector(size_type n, value_type x) : vector_(n + 2, x) {}
  void resize(size_type n, value_type x = value_type()) { vector_.resize(n + 2, x); }
  size_type size() const { return vector_.size() - 2; }
  value_type const& operator[](int i) const { return vector_[i+1]; }
  value_type& operator[](int i) { return vector_[i+1]; }
private:
  std::vector<value_type> vector_;
};

inline void copy2right(tabbed_vector<int>& vec) {
  int np, rank;
  MPI_Comm_size(MPI_COMM_WORLD, &np);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  int loclen = vec.size();
  if (np == 1) {
    vec[-1] = vec[loclen-1];
  } else {
    MPI_Status stat;
    MPI_Send(&vec[loclen-1], 1, MPI_INT, (rank + 1) % np, 0, MPI_COMM_WORLD);
    MPI_Recv(&vec[-1], 1, MPI_INT, (rank + np - 1) % np, 0, MPI_COMM_WORLD, &stat);
  }
}

inline void copy2left(tabbed_vector<int>& vec) {
  int np, rank;
  MPI_Comm_size(MPI_COMM_WORLD, &np);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  int loclen = vec.size();
  if (np == 1) {
    vec[loclen] = vec[0];
  } else {
    MPI_Status stat;
    MPI_Send(&vec[0], 1, MPI_INT, (rank + np - 1) % np, 0, MPI_COMM_WORLD);
    MPI_Recv(&vec[loclen], 1, MPI_INT, (rank + 1) % np, 0, MPI_COMM_WORLD, &stat);
  }
}

int main(int argc, char** argv) {

  MPI_Init(&argc, &argv);
  int np, rank;
  MPI_Comm_size(MPI_COMM_WORLD, &np);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  int loclen;
  if (rank == 0)
    loclen = L - (np - 1) * (L / np);
  else
    loclen = L / np;
  
  // inverse temperature
  double beta = 1 / T;

  // random number generator
  boost::mt19937 eng(SEED ^ (rank << 5));
  boost::variate_generator<boost::mt19937&, boost::uniform_real<> >
    random_01(eng, boost::uniform_real<>());

  // spin configuration
  tabbed_vector<int> spins(loclen);
  for (int s = 0; s < loclen; ++s) spins[s] = (random_01() < 0.5 ? 1 : -1);
  copy2right(spins);
  copy2left(spins);

  // measurement
  double ene = 0;
  double mag = 0;
  double mag2 = 0;
  double mag4 = 0;

  // timer
  boost::timer tm;
  
  for (int mcs = 0; mcs < MCSTEP + MCTHRM; ++mcs) {
    for (int s = 0; s < loclen; ++s) {
      double diff = 2 * spins[s] * (spins[s-1] + spins[s+1]);
      if (random_01() < 0.5 * (1 + std::tanh(-0.5 * beta * diff))) spins[s] = -spins[s];
      if (s == 0) copy2left(spins);
      if (s == loclen - 1) copy2right(spins);
    }
    if (mcs >= MCTHRM) {
      double m_loc = 0;
      double g_loc = 0;
      for (int s = 0; s < loclen; ++s) {
        g_loc -= spins[s] * spins[s+1];
        m_loc += spins[s];
      }
      double m, g;
      MPI_Reduce(&m_loc, &m, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
      MPI_Reduce(&g_loc, &g, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
      if (rank == 0) {
        g /= L;
        m /= L;
        ene += g;
        mag += m;
        mag2 += m * m;
        mag4 += std::pow(m, 4);
      }
    }
  }

  // output results
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) {
    std::cout << "Energy = " << ene / MCSTEP << std::endl;
    std::cout << "Magnetization = " << mag / MCSTEP << std::endl;
    std::cout << "Magnetization^2 = " << mag2 / MCSTEP << std::endl;
    std::cout << "Magnetization^4 = " << mag4 / MCSTEP << std::endl;
    std::cout << "Binder Ratio of Magnetization = " << mag2 * mag2 / mag4 / MCSTEP << std::endl;
    std::cerr << "Elapsed time = " << tm.elapsed() << " sec\n";
  }

  MPI_Finalize();
  return 0;
}
